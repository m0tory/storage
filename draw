-- DrawingLib VM-safe drop-in replacement
local RunService = game:GetService("RunService")
local coreGui = game:GetService("CoreGui")
local camera = workspace.CurrentCamera

-- Root GUI
local drawingUI = Instance.new("ScreenGui")
drawingUI.ResetOnSpawn = false
drawingUI.Name = "Drawing"
drawingUI.IgnoreGuiInset = true
drawingUI.DisplayOrder = 0x7fffffff
drawingUI.Parent = coreGui

-- Internal storage
local drawingIndex = 0
local activeObjects = {} -- stores all live objects
local updateQueue = {} -- for RenderStepped UI updates

local function convertTransparency(transparency)
	return math.clamp(1 - transparency, 0, 1)
end

local baseDrawingObj = {
	Visible = true,
	ZIndex = 0,
	Transparency = 1,
	Color = Color3.new(),
	Remove = function(self)
		setmetatable(self, nil)
	end
}

-- RenderStepped updater
RunService.RenderStepped:Connect(function()
	for obj, data in pairs(updateQueue) do
		if not data.Frame or not activeObjects[obj] then
			updateQueue[obj] = nil
		else
			data.UpdateFunc(data.Frame, data.Cache)
		end
	end
end)

local DrawingLib = {}
DrawingLib.Fonts = {["UI"]=0,["System"]=1,["Flex"]=2,["Monospace"]=3}

local drawingFontsEnum = {
	[0] = Enum.Font.Roboto,
	[1] = Enum.Font.Legacy,
	[2] = Enum.Font.SourceSans,
	[3] = Enum.Font.RobotoMono
}

local function getFontFromIndex(fontIndex)
	return drawingFontsEnum[fontIndex]
end

function DrawingLib.cleardrawcache()
	for obj in pairs(activeObjects) do
		if obj.Remove then
			obj:Remove()
		end
		activeObjects[obj] = nil
	end
	updateQueue = {}
end

local function createBaseObject(props)
	local obj = {}
	obj._cache = {}
	for k,v in pairs(props) do
		obj._cache[k] = v
	end
	setmetatable(obj, {
		__newindex = function(_, key, value)
			obj._cache[key] = value
		end,
		__index = function(_, key)
			if key == "Remove" then
				return function()
					if obj._frame then obj._frame:Destroy() end
					activeObjects[obj] = nil
					updateQueue[obj] = nil
					return baseDrawingObj.Remove(obj)
				end
			elseif key == "__OBJECT_EXISTS" then
				return activeObjects[obj] == true
			else
				return obj._cache[key]
			end
		end
	})
	return obj
end

function DrawingLib.new(drawingType)
	drawingIndex += 1

	if drawingType == "Line" then
		local obj = createBaseObject({
			From = Vector2.zero,
			To = Vector2.zero,
			Thickness = 1,
			Visible = true,
			Color = Color3.new(),
			ZIndex = 0,
			Transparency = 1
		})

		local frame = Instance.new("Frame")
		frame.Name = tostring(drawingIndex)
		frame.AnchorPoint = Vector2.new(0.5,0.5)
		frame.BorderSizePixel = 0
		frame.Parent = drawingUI
		obj._frame = frame

		local function update(frame, cache)
			local direction = cache.To - cache.From
			local center = (cache.To + cache.From) / 2
			local distance = direction.Magnitude
			local theta = math.deg(math.atan2(direction.Y, direction.X))
			frame.Position = UDim2.fromOffset(center.X, center.Y)
			frame.Rotation = theta
			frame.Size = UDim2.fromOffset(distance, cache.Thickness)
			frame.BackgroundColor3 = cache.Color
			frame.BackgroundTransparency = convertTransparency(cache.Transparency)
			frame.Visible = cache.Visible
			frame.ZIndex = cache.ZIndex
		end

		updateQueue[obj] = {Frame=frame, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end

	if drawingType == "Square" or drawingType == "Circle" then
		local obj = createBaseObject({
			Position = Vector2.zero,
			Size = Vector2.new(100,100),
			Radius = 50,
			Thickness = 1,
			Filled = false,
			Visible = true,
			Color = Color3.new(),
			ZIndex = 0,
			Transparency = 1
		})

		local frame = Instance.new("Frame")
		frame.Name = tostring(drawingIndex)
		frame.AnchorPoint = Vector2.new(0.5,0.5)
		frame.BorderSizePixel = 0
		frame.Parent = drawingUI
		local corner = Instance.new("UICorner")
		corner.Parent = frame
		obj._frame = frame

		local stroke = Instance.new("UIStroke")
		stroke.Parent = frame

		local function update(frame, cache)
			frame.Position = UDim2.fromOffset(cache.Position.X, cache.Position.Y)
			if drawingType=="Circle" then
				frame.Size = UDim2.fromOffset(cache.Radius*2, cache.Radius*2)
				corner.CornerRadius = UDim.new(1,0)
			else
				frame.Size = UDim2.fromOffset(cache.Size.X, cache.Size.Y)
				corner.CornerRadius = cache.Filled and UDim.new(1,0) or UDim.new(0,0)
			end
			stroke.Thickness = cache.Thickness
			stroke.Enabled = not cache.Filled
			stroke.Color = cache.Color
			stroke.Transparency = convertTransparency(cache.Transparency)
			frame.BackgroundColor3 = cache.Color
			frame.BackgroundTransparency = cache.Filled and convertTransparency(cache.Transparency) or 1
			frame.Visible = cache.Visible
			frame.ZIndex = cache.ZIndex
		end

		updateQueue[obj] = {Frame=frame, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end

	if drawingType == "Text" then
		local obj = createBaseObject({
			Text = "",
			Font = 0,
			Size = 14,
			Position = Vector2.zero,
			Center = false,
			Outline = false,
			OutlineColor = Color3.new(),
			Visible = true,
			Color = Color3.new(),
			ZIndex = 0,
			Transparency = 1
		})

		local label = Instance.new("TextLabel")
		label.Name = tostring(drawingIndex)
		label.AnchorPoint = Vector2.new(0.5,0.5)
		label.BorderSizePixel = 0
		label.BackgroundTransparency = 1
		label.Parent = drawingUI
		local stroke = Instance.new("UIStroke")
		stroke.Parent = label
		obj._frame = label

		local function update(label, cache)
			label.Text = cache.Text
			label.FontFace = getFontFromIndex(cache.Font)
			label.TextSize = cache.Size
			label.Position = UDim2.fromOffset(cache.Position.X, cache.Position.Y)
			label.TextColor3 = cache.Color
			label.TextTransparency = convertTransparency(cache.Transparency)
			label.Visible = cache.Visible
			label.ZIndex = cache.ZIndex
			stroke.Enabled = cache.Outline
			stroke.Color = cache.OutlineColor
			stroke.Transparency = convertTransparency(cache.Transparency)
		end

		updateQueue[obj] = {Frame=label, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end

	if drawingType == "Line" then
		-- handled above
	end

	if drawingType == "Image" then
		local obj = createBaseObject({
			Data = "",
			DataURL = "rbxassetid://0",
			Position = Vector2.zero,
			Size = Vector2.zero,
			Visible = true,
			ZIndex = 0,
			Color = Color3.new(),
			Transparency = 1
		})

		local image = Instance.new("ImageLabel")
		image.Name = tostring(drawingIndex)
		image.BackgroundTransparency = 1
		image.BorderSizePixel = 0
		image.Parent = drawingUI
		obj._frame = image

		local function update(img, cache)
			img.Position = UDim2.fromOffset(cache.Position.X, cache.Position.Y)
			img.Size = UDim2.fromOffset(cache.Size.X, cache.Size.Y)
			img.Image = cache.DataURL
			img.ImageColor3 = cache.Color
			img.ImageTransparency = convertTransparency(cache.Transparency)
			img.Visible = cache.Visible
			img.ZIndex = cache.ZIndex
		end

		updateQueue[obj] = {Frame=image, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end

	-- For Quad/Triangle, just use multiple lines
	if drawingType == "Quad" then
		local obj = createBaseObject({
			PointA = Vector2.zero,
			PointB = Vector2.zero,
			PointC = Vector2.zero,
			PointD = Vector2.zero,
			Thickness = 1,
			Filled = false,
			Visible = true,
			Color = Color3.new(),
			ZIndex = 0,
			Transparency = 1
		})

		obj._lines = {
			A = DrawingLib.new("Line"),
			B = DrawingLib.new("Line"),
			C = DrawingLib.new("Line"),
			D = DrawingLib.new("Line")
		}

		local function update(_, cache)
			obj._lines.A.From = cache.PointA; obj._lines.A.To = cache.PointB
			obj._lines.B.From = cache.PointB; obj._lines.B.To = cache.PointC
			obj._lines.C.From = cache.PointC; obj._lines.C.To = cache.PointD
			obj._lines.D.From = cache.PointD; obj._lines.D.To = cache.PointA
			for _, l in pairs(obj._lines) do
				l.Thickness = cache.Thickness
				l.Color = cache.Color
				l.Visible = cache.Visible
			end
		end

		updateQueue[obj] = {Frame=nil, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end

	if drawingType == "Triangle" then
		local obj = createBaseObject({
			PointA = Vector2.zero,
			PointB = Vector2.zero,
			PointC = Vector2.zero,
			Thickness = 1,
			Filled = false,
			Visible = true,
			Color = Color3.new(),
			ZIndex = 0,
			Transparency = 1
		})

		obj._lines = {
			A = DrawingLib.new("Line"),
			B = DrawingLib.new("Line"),
			C = DrawingLib.new("Line")
		}

		local function update(_, cache)
			obj._lines.A.From = cache.PointA; obj._lines.A.To = cache.PointB
			obj._lines.B.From = cache.PointB; obj._lines.B.To = cache.PointC
			obj._lines.C.From = cache.PointC; obj._lines.C.To = cache.PointA
			for _, l in pairs(obj._lines) do
				l.Thickness = cache.Thickness
				l.Color = cache.Color
				l.Visible = cache.Visible
			end
		end

		updateQueue[obj] = {Frame=nil, Cache=obj._cache, UpdateFunc=update}
		activeObjects[obj] = true
		return obj
	end
end

function DrawingLib.isrenderobj(obj)
	return activeObjects[obj] == true
end

function DrawingLib.getrenderproperty(obj, key)
	return obj._cache[key]
end

function DrawingLib.setrenderproperty(obj, key, value)
	obj[key] = value
end

return DrawingLib
